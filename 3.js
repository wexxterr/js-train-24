console.log("Завдання: 3 ==============================");

// Створюємо функцію task3, в якій буде виконуватися завдання
function task3() {
  // Створюємо функцію promise1, яка створює і повертає новий проміс
  // Метод new Promise приймає в якості параметра функцію (executor), яка має два параметри: resolve і reject.
  const promise1 = new Promise((resolve, reject) => {
    // Використовуємо setTimeout для імітації асинхронної операції, яка завершується через 1 секунду
    setTimeout(() => {
      // Викликаємо resolve з рядком 'Проміс 1 виконано', що означає успішне вирішення проміса
      resolve('Проміс 1 виконано')
    }, 1000)
  })

  // Створюємо функцію promise2, яка створює і повертає новий проміс, який відхиляється
  const promise2 = new Promise((resolve, reject) => {
    // Використовуємо setTimeout для імітації асинхронної операції, яка не вдається і відхиляє проміс через 2 секунди
    setTimeout(() => {
      // Викликаємо reject з рядком 'Проміс 2 відхилено', що означає відхилення проміса
      reject('Проміс 2 відхилено')
    }, 1000)
  })

  // Використовуємо Promise.allSettled який приймає масив промісів і повертає новий проміс, який вирішується, коли всі проміси вирішено або відхилено
  Promise.allSettled([promise1, promise2])
    // Він повертає масив об'єктів, кожний з яких відображає стан кожного проміса
    // Функція then викликається, коли проміс вирішено
    .then((results) => {
      // Вона приймає результати промісів і обробляє їх
      // Для кожного результату виводимо статус проміса
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          console.log(`Проміс ${index + 1} вирішено з результатом: ${result.value}`);
        } else if (result.status === 'rejected') {
          console.log(`Проміс ${index + 1} відхилено з причиною: ${result.reason}`);
        }
      });
    })
    // Функція finally викликається після того, як проміс вирішено або відхилено
    .finally(() => {
      // Вона використовується для виконання дій, які повинні виконуватися незалежно від того, чи було проміс вирішено чи відхилено
      // В нашому випадку ми просто виводимо повідомлення, "Завдання 3 завершено"
      console.log("Завдання 3 завершено")
    })
}

// Викликаємо функцію task3
task3();
